{
    "id": "TILE_SAMPLER",
    "label": "Tile Sampler",
    "category": "Generator",
    "description": "Tiles a pattern texture into a grid with per-tile random transform (Substance-style).",
    "locales": {
      "zh": {
        "Tile Sampler": "平铺采样器",
        "Tiles a pattern texture into a grid with per-tile random transform (Substance-style).": "将图案贴图平铺到网格中，并对每个格子做随机变换（Substance 风格）。",
        "Pattern": "图案",
        "Tiles": "网格(列/行)",
        "Scale": "缩放",
        "Rotation": "旋转",

        "Global Offset": "全局偏移",
        "Offset": "偏移",
        "Offset Type": "偏移类型",
        "Horizontal Quincux": "水平梅花形(错列)",
        "Vertical Quincux": "垂直梅花形(错列)",
        "Horizontal Decreasing Offset": "水平递增偏移(按行)",
        "Vertical Decreasing Offset": "垂直递增偏移(按列)",

        "Position Jitter": "位置抖动",
        "Position Multiplier": "位置应用比例",
        "Rotation Jitter": "旋转抖动",
        "Rotation Multiplier": "旋转应用比例",
        "Scale Jitter": "缩放抖动",
        "Scale Multiplier": "缩放应用比例",
        "Flip": "翻转",
        "Brightness": "亮度",
        "Brightness Jitter": "亮度抖动",
        "Brightness Multiplier": "亮度应用比例",
        "Mask Multiplier": "遮罩应用比例",
        "Blend Mode": "叠加模式",
        "Seed": "随机种子",
        "Result": "结果",
        "Tile ID": "格子ID",
        "Tile Random": "格子随机"
      }
    },
    "data": {
        "glsl": [
          "// Substance-style tile sampler with overlap and toroidal wrap across the whole image.",
          "//",
          "// - Overlap: evaluate neighboring tiles and pick the best candidate.",
          "// - Toroidal wrap: if an instance spills past uv edges, it appears on the opposite side.",
          "// - CUTOUT sampling: only sample pattern when transformed coords are inside [0,1].",
          "//",
          "// Multipliers (0..1) control the *fraction of tiles* affected by each property.",
          "// Example: position_multiplier=0.5 => about half the tiles apply position_jitter.",
          "//",
          "// tile_id output: normalized tile index in [0,1] (0 when no tile covers).",
          "// tile_rand output: normalized [0,1) value that varies with seed (useful for randomization).",
          "",
          "float hash11(float p) {",
          "    p = fract(p * 0.1031);",
          "    p *= p + 33.33;",
          "    p *= p + p;",
          "    return fract(p);",
          "}",
          "",
          "float hash21(vec2 p) {",
          "    vec3 p3 = fract(vec3(p.x, p.y, p.x) * 0.1031);",
          "    p3 += dot(p3, p3.yzx + 33.33);",
          "    return fract((p3.x + p3.y) * p3.z);",
          "}",
          "",
          "vec2 hash22(vec2 p) {",
          "    float n = hash21(p);",
          "    return vec2(n, hash11(n + 19.19));",
          "}",
          "",
          "vec2 rot2(vec2 v, float a) {",
          "    float c = cos(a), s = sin(a);",
          "    return mat2(c, -s, s, c) * v;",
          "}",
          "",
          "bool in01(vec2 p) {",
          "    return all(greaterThanEqual(p, vec2(0.0))) && all(lessThanEqual(p, vec2(1.0)));",
          "}",
          "",
          "ivec2 wrapTile(ivec2 t, ivec2 tiles) {",
          "    // Wrap into [0, tiles-1] even for negative t.",
          "    return ivec2(((t.x % tiles.x) + tiles.x) % tiles.x, ((t.y % tiles.y) + tiles.y) % tiles.y);",
          "}",
          "",
          "float applyGate(float index, float seed, float multiplier, float salt) {",
          "    float m = clamp(multiplier, 0.0, 1.0);",
          "    if (m <= 0.0) return 0.0;",
          "    if (m >= 1.0) return 1.0;",
          "    float r = hash11(index + seed + salt);",
          "    return (r < m) ? 1.0 : 0.0;",
          "}",
          "",
          "vec4 blendOp(int mode, vec4 a, vec4 b) {",
          "    // Uses the same numeric mode IDs as the BLEND node for shared modes:",
          "    // 0=Normal (not used here), 2=Multiply, 4=Max(Lighten), 5=Screen, 12=Add, 13=Subtract",
          "    if (mode == 12) return a + b;",
          "    if (mode == 13) return a - b;",
          "    if (mode == 2) return a * b;",
          "    if (mode == 4) return max(a, b);",
          "    if (mode == 5) return vec4(1.0) - (vec4(1.0) - a) * (vec4(1.0) - b);",
          "    return a + b;",
          "}",
          "",
          "void run(",
          "    vec2 uv,",
          "    sampler2D pattern,",
          "    vec2 tiles,",
          "    float scale,",
          "    float rotation,",
          "    vec2 global_offset,",
          "    float offset,",
          "    int offset_type,",
          "",
          "    float position_jitter,",
          "    float position_multiplier,",
          "    float rotation_jitter,",
          "    float rotation_multiplier,",
          "    float scale_jitter,",
          "    float scale_multiplier,",
          "",
          "    vec2 flip,",
          "",
          "    float brightness,",
          "    float brightness_jitter,",
          "    float brightness_multiplier,",
          "",
          "    float mask_multiplier,",
          "    int blend_mode,",
          "",
          "    float seed,",
          "    out vec4 result,",
          "    out float tile_id,",
          "    out float tile_rand",
          ") {",
          "    ivec2 tilesI = max(ivec2(1), ivec2(int(max(1.0, floor(tiles.x + 0.5))), int(max(1.0, floor(tiles.y + 0.5)))));",
          "    vec2 tilesF = vec2(tilesI);",
          "    float tileCount = float(tilesI.x * tilesI.y);",
          "",
          "    vec4 best = vec4(0.0);",
          "    float bestScore = -1e20;",
          "    float bestIndex = -1.0;",
          "    vec4 best2 = vec4(0.0);",
          "    float best2Score = -1e20;",
          "    float best2Index = -1.0;",
          "    vec4 cover = vec4(0.0);",
          "    float coverIndex = -1.0;",
          "    vec4 coverUnder = vec4(0.0);",
          "    float coverUnderIndex = -1.0;",
          "    vec4 accum = vec4(0.0);",
          "    bool anyHit = false;",
          "    float idSum = 0.0;",
          "    float randSum = 0.0;",
          "    float wSum = 0.0;",
          "",
          "    const int COVER_MODE = 100;",
          "",
          "    vec2 flipP = clamp(flip, vec2(0.0), vec2(1.0));",
          "",
          "    // Toroidal wrap: evaluate uv shifted by +/-2 so global edges wrap even under larger transforms.",
          "    for (int sy = -2; sy <= 2; sy++) {",
          "        for (int sx = -2; sx <= 2; sx++) {",
          "            vec2 uvShift = uv + global_offset + vec2(float(sx), float(sy));",
          "            vec2 gridUv = uvShift * tilesF;",
          "",
          "            // Grid offset modes (Substance-style row/column offsets).",
          "            // offset is in UV units. For horizontal modes, x is shifted; for vertical modes, y is shifted.",
          "            int rowAbs = int(floor(gridUv.y));",
          "            int colAbs = int(floor(gridUv.x));",
          "            int rowWrap = ((rowAbs % tilesI.y) + tilesI.y) % tilesI.y;",
          "            int colWrap = ((colAbs % tilesI.x) + tilesI.x) % tilesI.x;",
          "",
          "            if (offset != 0.0) {",
          "                if (offset_type == 0) {",
          "                    // Horizontal quincux: shift every other row by offset.",
          "                    float odd = float(rowWrap % 2);",
          "                    gridUv.x += (odd * offset) * tilesF.x;",
          "                } else if (offset_type == 1) {",
          "                    // Vertical quincux: shift every other column by offset.",
          "                    float odd = float(colWrap % 2);",
          "                    gridUv.y += (odd * offset) * tilesF.y;",
          "                } else if (offset_type == 2) {",
          "                    // Horizontal decreasing offset: (offset / rows) * rowIndex.",
          "                    float t = float(rowWrap) / max(1.0, tilesF.y);",
          "                    gridUv.x += (offset * t) * tilesF.x;",
          "                } else if (offset_type == 3) {",
          "                    // Vertical decreasing offset: (offset / cols) * colIndex.",
          "                    float t = float(colWrap) / max(1.0, tilesF.x);",
          "                    gridUv.y += (offset * t) * tilesF.y;",
          "                }",
          "            }",
          "",
          "            ivec2 baseCell = ivec2(floor(gridUv));",
          "",
          "            // Overlap: evaluate 9x9 neighborhood tiles to avoid missing far-reaching candidates.",
          "            for (int oy = -4; oy <= 4; oy++) {",
          "                for (int ox = -4; ox <= 4; ox++) {",
          "                    // IMPORTANT: use the unwrapped cell for local coordinate math,",
          "                    // but wrap for per-tile randomness/ID so the whole image tiles seamlessly.",
          "                    ivec2 cellAbsI = baseCell + ivec2(ox, oy);",
          "                    ivec2 cellI = wrapTile(cellAbsI, tilesI);",
          "                    vec2 cellAbs = vec2(cellAbsI);",
          "                    vec2 cellW = vec2(cellI);",
          "",
          "                    vec2 local = (gridUv - cellAbs) - 0.5;",
          "",
          "                    // Per-tile random values (0..1). Random repeats with wrapped tiles (toroidal).",
          "                    vec2 r0 = hash22(cellW + seed);",
          "                    vec2 r1 = hash22(cellW + seed + 7.13);",
          "                    // Stable tile index in [0, tileCount).",
          "                    float index = float(cellI.x + cellI.y * tilesI.x);",
          "",
          "                    float gPos = applyGate(index, seed, position_multiplier, 201.3);",
          "                    float gRot = applyGate(index, seed, rotation_multiplier, 207.9);",
          "                    float gScl = applyGate(index, seed, scale_multiplier, 213.4);",
          "                    float gBri = applyGate(index, seed, brightness_multiplier, 219.1);",
          "                    float gHide = applyGate(index, seed, mask_multiplier, 333.3);",
          "",
          "                    vec2 posJ = ((r0 * 2.0 - 1.0) * position_jitter * 0.5) * gPos;",
          "                    float rotDeg = rotation + ((r1.x * 2.0 - 1.0) * rotation_jitter) * gRot;",
          "                    float a = radians(rotDeg);",
          "",
          "                    float sRand = (1.0 + (r1.y * 2.0 - 1.0) * scale_jitter);",
          "                    float s = max(1e-4, scale * mix(1.0, sRand, gScl));",
          "",
          "                    vec2 p = (rot2((local - posJ) / s, -a)) + 0.5;",
          "",
          "                    // Per-tile flips (probabilities in [0,1]).",
          "                    if (flipP.x > 0.0) {",
          "                        float rf = hash11(index + seed + 113.1);",
          "                        if (rf < flipP.x) p.x = 1.0 - p.x;",
          "                    }",
          "                    if (flipP.y > 0.0) {",
          "                        float rf = hash11(index + seed + 127.7);",
          "                        if (rf < flipP.y) p.y = 1.0 - p.y;",
          "                    }",
          "",
          "                    if (in01(p) && gHide < 0.5) {",
          "                        vec4 c = texture(pattern, p);",
          "",
          "                        // Brightness controls (global + per-tile jitter).",
          "                        float br = max(0.0, brightness);",
          "                        if (brightness_jitter != 0.0 && gBri > 0.0) {",
          "                            float rB = (hash11(index + seed + 91.7) * 2.0 - 1.0);",
          "                            br = max(0.0, brightness + rB * brightness_jitter);",
          "                        }",
          "                        c.rgb *= br;",
          "",
          "                        // Score by how far inside the tile we are (reduces seams + makes tile_id stable).",
          "                        float mx = min(p.x, 1.0 - p.x);",
          "                        float my = min(p.y, 1.0 - p.y);",
          "                        float margin = min(mx, my);",
          "                        // Deterministic tie-breaker so exact ties don't depend on loop order.",
          "                        float tie = hash11(index + seed) * 1e-6;",
          "                        float score = margin + tie;",
          "                        if (score > bestScore) {",
          "                            best2Score = bestScore;",
          "                            best2 = best;",
          "                            best2Index = bestIndex;",
          "                            bestScore = score;",
          "                            best = c;",
          "                            bestIndex = index;",
          "                        } else if (score > best2Score) {",
          "                            best2Score = score;",
          "                            best2 = c;",
          "                            best2Index = index;",
          "                        }",
          "",
          "                        // Overlap blending: when enabled, combine all candidates that cover this pixel.",
          "                        if (blend_mode == COVER_MODE) {",
          "                            // Cover: larger tile_id is on top, but honor alpha by compositing over the next layer.",
          "                            float wa = clamp(c.a, 0.0, 1.0);",
          "                            if (wa > 0.0) {",
          "                                if (index > coverIndex) {",
          "                                    coverUnderIndex = coverIndex;",
          "                                    coverUnder = cover;",
          "                                    coverIndex = index;",
          "                                    cover = c;",
          "                                } else if (index > coverUnderIndex) {",
          "                                    coverUnderIndex = index;",
          "                                    coverUnder = c;",
          "                                }",
          "                            }",
          "                        } else if (blend_mode != 0) {",
          "                            // Track blended ID/random as a weighted average over contributing tiles.",
          "                            float w = clamp(c.a, 0.0, 1.0);",
          "                            if (w > 0.0) {",
          "                                idSum += index * w;",
          "                                randSum += hash11(index + seed) * w;",
          "                                wSum += w;",
          "                            }",
          "                            if (!anyHit) {",
          "                                accum = c;",
          "                                anyHit = true;",
          "                            } else {",
          "                                accum = blendOp(blend_mode, accum, c);",
          "                            }",
          "                        }",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    if (blend_mode == 0) {",
          "        result = best;",
          "    } else if (blend_mode == COVER_MODE) {",
          "        // Cover: alpha-over compositing of the top tile (largest id) over the next tile (2nd-largest id).",
          "        if (coverIndex < 0.0) {",
          "            result = vec4(0.0);",
          "        } else if (coverUnderIndex < 0.0) {",
          "            result = cover;",
          "        } else {",
          "            float aTop = clamp(cover.a, 0.0, 1.0);",
          "            vec3 rgb = cover.rgb * aTop + coverUnder.rgb * (1.0 - aTop);",
          "            float a = aTop + clamp(coverUnder.a, 0.0, 1.0) * (1.0 - aTop);",
          "            result = vec4(rgb, a);",
          "        }",
          "    } else {",
          "        result = anyHit ? clamp(accum, vec4(0.0), vec4(1.0)) : vec4(0.0);",
          "    }",
          "",
          "    float denom = max(1.0, tileCount - 1.0);",
          "    if (blend_mode != 0 && blend_mode != COVER_MODE) {",
          "        tile_id = (wSum > 0.0) ? ((idSum / wSum) / denom) : 0.0;",
          "        tile_rand = (wSum > 0.0) ? (randSum / wSum) : 0.0;",
          "    } else if (blend_mode == COVER_MODE) {",
          "        tile_id = (coverIndex >= 0.0) ? (coverIndex / denom) : 0.0;",
          "        tile_rand = (coverIndex >= 0.0) ? hash11(coverIndex + seed) : 0.0;",
          "    } else {",
          "        tile_id = (bestIndex >= 0.0) ? (bestIndex / denom) : 0.0;",
          "        tile_rand = (bestIndex >= 0.0) ? hash11(bestIndex + seed) : 0.0;",
          "    }",
          "}"
        ],
      "inputs": [
        { "id": "pattern", "name": "Pattern", "type": "sampler2D" },
        { "id": "tiles", "name": "Tiles", "type": "vec2" },
        { "id": "scale", "name": "Scale", "type": "float" },
        { "id": "rotation", "name": "Rotation", "type": "float" },

        { "id": "global_offset", "name": "Global Offset", "type": "vec2" },
        { "id": "offset", "name": "Offset", "type": "float" },
        { "id": "offset_type", "name": "Offset Type", "type": "int" },

        { "id": "position_jitter", "name": "Position Jitter", "type": "float" },
        { "id": "position_multiplier", "name": "Position Multiplier", "type": "float" },
        { "id": "rotation_jitter", "name": "Rotation Jitter", "type": "float" },
        { "id": "rotation_multiplier", "name": "Rotation Multiplier", "type": "float" },
        { "id": "scale_jitter", "name": "Scale Jitter", "type": "float" },
        { "id": "scale_multiplier", "name": "Scale Multiplier", "type": "float" },

        { "id": "flip", "name": "Flip", "type": "vec2" },

        { "id": "brightness", "name": "Brightness", "type": "float" },
        { "id": "brightness_jitter", "name": "Brightness Jitter", "type": "float" },
        { "id": "brightness_multiplier", "name": "Brightness Multiplier", "type": "float" },

        { "id": "mask_multiplier", "name": "Mask Multiplier", "type": "float" },

        { "id": "blend_mode", "name": "Blend Mode", "type": "int" },

        { "id": "seed", "name": "Seed", "type": "float" }
      ],
      "outputs": [
        { "id": "result", "name": "Result", "type": "vec4" },
        { "id": "tile_id", "name": "Tile ID", "type": "float" },
        { "id": "tile_rand", "name": "Tile Random", "type": "float" }
      ],
      "outputType": "vec4",
      "uniforms": {
        "pattern": { "type": "sampler2D", "value": null, "widget": "image" },
        "tiles": { "type": "vec2", "value": [4.0, 4.0], "widget": "default" },
        "scale": { "type": "float", "value": 1.0, "widget": "slider", "widgetConfig": { "min": 0.01, "max": 2.0, "step": 0.01 } },
        "rotation": { "type": "float", "value": 0.0, "widget": "angle", "widgetConfig": { "min": -180.0, "max": 180.0, "step": 1.0 } },

        "global_offset": { "type": "vec2", "value": [0.0, 0.0], "widget": "default" },
        "offset": { "type": "float", "value": 0.0, "widget": "slider", "widgetConfig": { "min": -1.0, "max": 1.0, "step": 0.01 } },
        "offset_type": {
          "type": "int",
          "value": 0,
          "widget": "enum",
          "widgetConfig": {
            "enumOptions": [
              { "label": "Horizontal Quincux", "value": 0 },
              { "label": "Vertical Quincux", "value": 1 },
              { "label": "Horizontal Decreasing Offset", "value": 2 },
              { "label": "Vertical Decreasing Offset", "value": 3 }
            ]
          }
        },

        "position_jitter": { "type": "float", "value": 0.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },
        "position_multiplier": { "type": "float", "value": 1.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },
        "rotation_jitter": { "type": "float", "value": 0.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 180.0, "step": 1.0 } },
        "rotation_multiplier": { "type": "float", "value": 1.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },
        "scale_jitter": { "type": "float", "value": 0.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },
        "scale_multiplier": { "type": "float", "value": 1.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },

        "flip": { "type": "vec2", "value": [0.0, 0.0], "widget": "default" },

        "brightness": { "type": "float", "value": 1.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 2.0, "step": 0.01 } },
        "brightness_jitter": { "type": "float", "value": 0.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },
        "brightness_multiplier": { "type": "float", "value": 1.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },

        "mask_multiplier": { "type": "float", "value": 0.0, "widget": "slider", "widgetConfig": { "min": 0.0, "max": 1.0, "step": 0.01 } },

        "blend_mode": {
          "type": "int",
          "value": 0,
          "widget": "enum",
          "widgetConfig": {
            "enumOptions": [
              { "label": "Normal", "value": 0 },
              { "label": "Cover", "value": 100 },
              { "label": "Add", "value": 12 },
              { "label": "Subtract", "value": 13 },
              { "label": "Multiply", "value": 2 },
              { "label": "Screen", "value": 5 },
              { "label": "Max", "value": 4 }
            ]
          }
        },

        "seed": { "type": "float", "value": 0.0, "widget": "number", "widgetConfig": { "step": 1.0 } }
      }
    }
  }
